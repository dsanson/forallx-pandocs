Quantified logic
================

This chapter introduces a logical language called QL. It is a version of
*quantified logic*, because it allows for quantifiers like *all* and
*some*. Quantified logic is also sometimes called *predicate logic*,
because the basic units of the language are predicates and terms.

**8.1 From sentences to predicates**
-----------------------------------

Consider the following argument, which is valid in English:

> | <span class="premise"> If everyone knows logic, then either no one will be confused or everyone will. Everyone will be confused only if we try to believe a contradiction. Everyone knows logic. </span>
> | <span class="conclusion"> If we don't try to believe a contradiction, then no one will be
> confused.</span>


In order to symbolize this in SL, we will need a symbolization key.

> **L:** Everyone knows logic. <br/>
> **N:** No one will be confused. <br/>
> **E:** Everyone will be confused. <br/>
> **B:** We try to believe a contradiction.

Notice that $N$ and $E$ are both about people being confused, but they
are two separate sentence letters. We can't replace $E$ with $\neg N$.
Why not? $\neg N$ means 'It is not the case that no one will be
confused.' This would be the case if even one person were confused, so
it is a long way from saying that *everyone* will be confused.

Because we have separate sentence letters for $N$ and $E$, however, our
formalization does not encode any connection between the two. They are
just two atomic sentences which might be true or false independently. It
is impossible for it to be the case that both no one and everyone was
confused. As sentences of SL, however, there is a truth-value assignment
for which $N$ and $E$ are both true. This is a limitation of the
descriptive power of SL. Some features of English sentences are not
preserved in SL. Our new language, QL, will preserve more of this
structure.

Expressions like 'no one', 'everyone', and 'anyone' are called
*quantifiers*. By translating $N$ and $E$ as separate atomic sentences,
we leave out the *quantifier structure* of the sentences. In the example
we've been discussing, the quantifier structure is not terribly
important. The argument is valid without reference to it. As such, we
can safely ignore it. To see this, we translate the argument to SL:

> | <span class="premise">$L \supset (N \lor E)$ </span>
> | <span class="premise"> $E \supset B$ </span>
> | <span class="premise"> $L$</span>
> | <span class="conclusion"> $\neg B \supset N$</span>

This is a valid argument form in SL. (You can construct a truth table, a
tree, or a natural deduction proof to confirm this.)

Now consider another argument. This one is also valid in English.

> | <span class="premise"> Willard is a logician. All logicians wear funny hats.</span>
> | <span class="conclusion"> Willard wears a funny hat.</span>

To symbolize it in SL, we define a symbolization key:

> **L:** Willard is a logician. <br/>
> **A:** All logicians wear funny hats. <br/>
> **F:** Willard wears a funny hat.

Now we symbolize the argument:

> | <span class="premise">$L$</span>
> | <span class="premise"> $A$</span>
> | <span class="conclusion"> $F$</span>


This is pretty obviously an *invalid* SL form. Nevertheless, this is
clearly a valid argument in English. It's impossible for the premises to
be true without the conclusion also being true. But the SL symbolization
leaves out all quantificational structure in virtue of which it is
valid. The sentence 'All logicians wear funny hats' says something
specific about both logicians and hat-wearing. By not translating this
structure, treating the whole sentence as an atom, we lose the
connection between Willard's being a logician and Willard's wearing a
hat.

Some arguments with quantifier structure can be captured in SL, like the
first example, even though SL ignores the quantifier structure. Other
arguments' validity cannot be captured in SL, like the second example.
Notice that the problem is not that we have made a mistake while
symbolizing the second argument. We gave a perfectly appropriate
translation; indeed, these are the best symbolizations we can give for
these arguments *in SL*.

If an English argument is properly translated into a form that is valid
in SL, that argument is valid, even if it involves quantifiers. But if
it does not have a valid SL form, that doesn't mean the English argument
is invalid; valid arguments can have invalid forms. It just means that
SL doesn't *show* that the argument is valid. This will be the case when
the argument's quantifier structure plays an important role in its
validity.

Similarly, if a sentence with quantifiers comes out as a
*tautology in SL*, then the English sentence is logically true.
If it comes out as
*contingent in SL*, then this might be because of the structure
of the quantifiers that gets removed when we translate into the
formal language.

In order to symbolize arguments that rely on quantifier structure, we
need to develop a different, richer, logical language. We will call this
language 'quantified logic', or QL.

**8.2 Building blocks of QL**
----------------------------

Our first key notion in QL will be **predicates**. A predicate
is analogous to an English description --- an expression like
'is a dog' or 'has black fur'. Such descriptions are not
sentences on their own. They are neither true nor false. They
are descriptions that apply to some objects, but not to others.
In order to be true or false, we need to specify an object: Who
or what is it that is said to be a dog, or to have black fur? In
SL, we have no way to give meaningful translations to English
terms that are not full sentences. In QL, we will.

The details of this will be explained in the rest of the chapter, but
here is the basic idea: In QL, we will represent predicates with capital
letters. For instance, we might let $D$ stand for '<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> is a dog.' We will
use lower-case letters as the names of specific things. For instance, we
might let $b$ stand for Bertie. The expression $Db$ will be a sentence
in QL. Given this symbolization, $Db$ is a translation of the sentence
'Bertie is a dog.'

In order to represent quantifier structure, we will also have symbols
that represent quantifiers. For instance, '$\exists$' will mean 'There
is some <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>.' So to say that there is a dog, we can write $\exists x Dx$;
that is: There is some $x$ such that $x$ is a dog.

That will come later. We start by defining singular terms and
predicates.

**8.3 Singular terms**
----------------------

In English, a **singular term** is a word or phrase that refers to a *specific* person,
place, or thing. The word 'dog' is not a singular term, because it is a
general term that could apply to many individual animals. The phrase
'Jonathan's dog Mezzo' is a singular term, because it refers to a
specific little poodle mix. She is black, and soft, and wonderful.

A **proper name** is a singular term that picks out an individual directly. The name
'Emerson' is a proper name, and the name alone does not tell you
anything about Emerson. Of course, some names are traditionally given to
boys, and others are traditionally given to girls. If 'Jack Hathaway' is
used as a singular term, you might guess that it refers to a man.
However, the name does not necessarily mean that the person referred to
is a man --- or even that the creature referred to is a person. Jack
might be a giraffe for all you could tell just from the name. There is a
great deal of philosophical action surrounding this issue, but the
important point here is that a name is a singular term because it picks
out a single, specific individual.

Other singular terms more obviously convey information about the thing
to which they refer. For instance, you can tell without being told
anything further that 'Jonathan's dog Mezzo' is a singular term that
refers to a dog. A **definite description** picks out an individual by means of a unique
description. In English, definite descriptions are often phrases of the
form 'the such-and-so.' They refer to *the* specific thing that matches
the given description. For example, 'the tallest member of Monty Python'
and 'the first emperor of China' are definite descriptions. A
description that does not pick out a specific individual is not a
definite description. 'A member of Monty Python' and 'an emperor of
China' are not definite descriptions. We'll discuss definite
descriptions in more detail in Chapter 12.

In English, the specification of a singular term may depend on
context;
'Willard' means a specific person and not just someone named
Willard;
'P.D. Magnus' as a logical singular term means the original
author of this textbook, not the other person who has the same name. We live with
this kind of ambiguity in English, but it is important to keep in mind
that singular terms in QL must refer to just one specific thing.

In QL, we will symbolize singular terms with lower-case letters $a$
through $w$. We can add subscripts if we want to use some letter more
than once. So $a,b,c,\ldots w, a_1, f_{32}, j_{390}$, and $m_{12}$ are
all terms in QL.

Singular terms are called **constants** because they pick out specific individuals.
Note that $x, y$, and $z$ are not constants in QL. They will be **variables**,
letters which do not stand for any specific thing. We will need them
when we introduce quantifiers.

**8.4 Predicates**
------------------

Simple one-place predicates are properties of individuals. They are
things you can say about an object. Here are some one-place predicates:

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> is a dog'

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> is a member of Monty Python'

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>'s favourite ramen place is in Gastown'

'An anvil was dropped from a very high height onto <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>'s head'


Predicates like these are called **one-place** or **monadic**, because there is only one blank to
fill in. A one-place predicate and a singular term combine to make a sentence.

Other predicates are about the *relation* between two things. For
instance:

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> is bigger than <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>'

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> is to the left of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>'

'<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> owes money to <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>'

These are **two-place** or **dyadic** predicates, because they need to be filled in with two
terms in order to make a sentence.

In general, you can think about predicates as schematic sentences that
need to be filled out with some number of terms. Conversely, you can
start with sentences and make predicates out of them by removing terms.
Consider the sentence, 'Buchanan Tower is North of Barber but South of
Buchanan E.' By removing a singular term, we can recognize this sentence
as using any of three different monadic predicates:

<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>is North of Barber but South of Buchanan E.

Buchanan Tower is North of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> but South of Buchanan E.

Buchanan Tower is North of Barber but South of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>.

By removing two singular terms, we can recognize three different dyadic
predicates:

Buchanan Tower is North of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> but South of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>.

<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>is North of Barber but South of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>.

<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>is North of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> but South of Buchanan E.

By removing all three singular terms, we can recognize one or predicate:

<span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>is North of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span> but South of <span style="border-bottom: 1px solid black; padding-left: 50px">&nbsp;</span>.

If we are translating this sentence into QL, should we translate it with
a one-, two-, or three-place predicate? It depends on what we want to be
able to say. If we're only interested in discussing the location of
buildings relative to Barber, then the generality of the three-place
predicate is unnecessary. If we only want to discuss whether buildings
are North of Barber and South of BUCH E, a one-place predicate will be
enough.

In general, we can have predicates with as many places as we need.
Predicates with more than one place are called . Predicates with $n$
places, for some number $n$, are called or . You can make an $n$-adic
predicate by replacing $n$ names in any sentence with blanks. You can
even have a 0-place predicate --- this would be the result of replacing
$0$ names in a sentence with blanks. In other words, a 0-place predicate
is just a sentence.

In QL, we symbolize predicates with capital letters $A$ through $Z$,
with or without subscripts. When we give a symbolization key for
predicates, we will not use blanks; instead, we will use variables. By
convention, constants are listed at the end of the key. So we might
write a key that looks like this:

> **$Ax$:** $x$ is angry.<br/>
> **$Hx$:** $x$ is happy.<br/>
> **$T_1xy$:** $x$ is at least as tall as $y$.<br/>
> **$T_2xy$:** $x$ is at least as tough as $y$.<br/>
> **$Bxyz$:** $y$ is between $x$ and $z$. <br/>
> **$d$:** Donald <br/>
> **$g$:** Gregor <br/>
> **$m$:** Marybeth


We can symbolize sentences that use any combination of these predicates
and terms. For example:

> | 1. <span class="premise">Donald is angry.</span>
> | 2. <span class="premise">If Donald is angry, then so are Gregor and Marybeth.</span>
> | 3. <span class="premise">Marybeth is at least as tall and as tough as Gregor.</span>
> | 4. <span class="premise">Donald is shorter than Gregor.</span>
> | 5. <span class="premise">Gregor is between Donald and Marybeth.</span>



Sentence 1 is straightforward: $Ad$. The '$x$' in the key entry '$Ax$' is just a
placeholder; we replace it with other terms when translating.

Sentence 2 can be paraphrased as, 'If $Ad$, then $Ag$ and $Am$.' QL has all the
truth-functional connectives of SL, so we translate this as
$Ad \supset (Ag\ \&\ Am)$.

Sentence 3 can be translated as $T_1mg\ \&\ T_2mg$.

Sentence 4might seem as if it requires a new predicate. If we only needed to
symbolize this sentence, we could define a predicate like $Sxy$ to mean
'$x$ is shorter than $y$.' However, this would ignore the logical
connection between 'shorter' and 'taller.' Considered only as symbols of
QL, there is no connection between $S$ and $T_1$. They might mean
anything at all. Instead of introducing a new predicate, we paraphrase
sentence 4 using predicates already in our key: 'It is not the case that Donald is
as tall or taller than Gregor.' We can translate it as $\neg T_1dg$.

Sentence 5 requires that we pay careful attention to the order of terms in the key.
It becomes $Bdgm$.

Quantifiers
-----------

We are now ready to introduce quantifiers. Quantifiers (unlike names and
predicates) are a new kind of logical connective; like conjunction,
negation, etc., they can govern the interpretation of a QL sentence.
Consider these English sentences:

> | 6. <span class="premise">Everyone is happy.</span>
> | 7. <span class="premise">Everyone is at least as tough as Donald.</span>
> | 8. <span class="premise">Someone is angry.</span>


It might be tempting to translate sentence 6 as
$Hd\ \&\ Hg\ \&\ Hm$. Yet this would only say that Donald, Gregor, and
Marybeth are happy. We want to say that *everyone* is happy, even if we
have not defined a constant to name them. In order to do this, we
introduce the '$\forall$' symbol. This is called the **universal quantifier**.

A quantifier is placed in front of the formula that it binds. It always
comes along with an associated variable. Typically that formula will
include the same variable. We can translate sentence 6 as $\forall x Hx$.
Paraphrased partially into English, this means 'For all $x$, $x$ is
happy.'

We call $\forall x$ an *x-quantifier*. The formula that follows the
quantifier is called the *scope* of the quantifier. We will give a
formal definition of scope later, but intuitively it is the part of the
sentence that the quantifier quantifies over. In $\forall x Hx$, the
scope of the universal quantifier is $Hx$.

Sentence 7 can be paraphrased as, 'For all $x$, $x$ is at least as tough as Donald.' This
translates as $\forall x T_2xd$.

In these quantified sentences, the variable $x$ is serving as a kind of
placeholder. The expression $\forall x$ means that you can pick anyone
and put them in as $x$. There is no special reason to use $x$ rather
than some other variable. The sentence $\forall x Hx$ means exactly the
same thing as $\forall y Hy$, $\forall z Hz$, and $\forall x_5 Hx_5$.

To translate sentence 8, we introduce another new symbol: the **existential quantifier**, $\exists$. Like
the universal quantifier, the existential quantifier requires a
variable. Sentence 8 can be translated as $\exists x Ax$. This means that there is some $x$
which is angry. More precisely, it means that there is *at least one*
angry person. Once again, the variable is a kind of placeholder; we
could just as easily have translated sentence 8 as $\exists z Az$.

Consider these further sentences:

> | 9. <span class="premise">No one is angry.</span>
> | 10. <span class="premise">There is someone who is not happy.</span>
> | 11. <span class="premise">Not everyone is happy.</span>

Sentence 9 can be
paraphrased as, 'It is not the case that someone is angry.' This can be
translated using negation and an existential quantifier:
$\neg \exists x Ax$. Yet sentence 9 could also be
paraphrased as, 'Everyone is not angry.' With this in mind, it can be
translated using negation and a universal quantifier:
$\forall x \neg Ax$. Both of these are acceptable translations, because
they are logically equivalent. The critical thing is whether the
negation comes before or after the quantifier.

In general, $\forall x\Phi$ is logically equivalent to
$\neg\exists x\neg\Phi$. This means that any sentence which can be
symbolized with a universal quantifier can be symbolized with an
existential quantifier, and vice versa. One translation might seem more
natural than the other, but there is no logical difference in
translating with one quantifier rather than the other. For some
sentences, it will simply be a matter of taste.

Sentence 10 is
most naturally paraphrased as, 'There is some $x$ such that $x$ is not
happy.' This becomes $\exists x \neg Hx$. Equivalently, we could write
$\neg\forall x Hx$.

Sentence  11 is
most naturally translated as $\neg\forall x Hx$. This is logically
equivalent to sentence 10 and so could also be translated as
$\exists x \neg Hx$.

Universe of discourse
---------------------

Given the symbolization key we have been using, $\forall xHx$ means
'Everyone is happy.' Who is included in this *everyone*? When we use
sentences like this in English, we usually do not mean everyone now
alive on the Earth. We certainly do not mean everyone who was ever alive
or who will ever live. We mean something more modest: everyone in the
building, everyone in the class, or everyone in the room.

In order to eliminate this ambiguity, we will need to specify a **universe of discourse**---
abbreviated UD. The UD is the set of things that we are talking about.
So if we want to talk about people in Chicago, we define the UD to be
people in Chicago. We write this at the beginning of the symbolization
key, like this:

> **$UD$:** people in Chicago. <br/>


The quantifiers *range over* the universe of discourse. Given this UD,
$\forall x$ means 'Everyone in Chicago' and $\exists x$ means 'Someone
in Chicago.' Each constant names some member of the UD, so we can only
use this UD with the symbolization key above if Donald, Gregor, and
Marybeth are all in Chicago. If we want to talk about people in places
besides Chicago, then we need to include those people in the UD.

In QL, the UD must be *non-empty*; that is, it must include at least one
thing. It is possible to construct formal languages that allow for empty
UDs, but this introduces complications; such languages are beyond the
scope of this book.

Even allowing for a UD with just one member can produce some strange
results. Suppose we have this as a symbolization key:


> **$UD$:** the Eiffel Tower<br/>
> **$Px$:** $x$ is in Paris.<br/>


The sentence $\forall x Px$ might be paraphrased in English as
'Everything is in Paris.' Yet that would be misleading. It means that
everything *in the UD* is in Paris. This UD contains only the Eiffel
Tower, so with this symbolization key $\forall x Px$ just means that the
Eiffel Tower is in Paris. We will rarely work with such bizarre domains
as this.

It is a rule in QL that each constant will pick out exactly one member
of the UD. (There is no rule prohibiting multiple different constants
from referring to the same member of the UD.)

Translating to QL
-----------------

We now have the basic pieces of QL. Translating more complicated
sentences will only be a matter of knowing the right way to combine
predicates, constants, quantifiers, variables, and sentential
connectives. Consider these sentences:

> | 12. <span class="premise">Every coin in my pocket is a loonie.</span>
> | 13. <span class="premise">Some coin on the table is a dime.</span>
> | 14. <span class="premise">Not all the coins on the table are loonies.</span>
> | 15. <span class="premise">None of the coins in my pocket are dimes.</span>


In providing a symbolization key, we need to specify a UD. Since we are
talking about coins in my pocket and on the table, the UD must at least
contain all of those coins. Since we are not talking about anything
besides coins, we let the UD be all coins. Since we are not talking
about any specific coins, we do not need to define any constants. So we
define this key:

> **$UD$:** all coins<br/>
> **$Px$:** $x$ is in my pocket.<br/>
> **$Tx$:** $x$ is on the table.<br/>
> **$Lx$:** $x$ is a loonie.<br/>
> **$Dx$:** $x$ is a dime.<br/>


Sentence 12 is
most naturally translated with a universal quantifier. The universal
quantifier says something about everything in the UD, not just about the
coins in my pocket. Sentence 12 means that, for any coin, *if* that coin is in my
pocket, *then* it is a loonie. So we can translate it as
$\forall x(Px \supset Lx)$.

Since sentence 12 is about coins that are both in my pocket *and* that
are loonies, it might be tempting to translate it using a conjunction.
However, the sentence $\forall x(Px \& Lx)$ would mean that
everything in the UD is both in my pocket and a loonie: All the coins
that exist are loonies in my pocket. This would be nice, but it means
something very different than sentence 12.

Sentence 13 is
most naturally translated with an existential quantifier. It says that
there is some coin which is both on the table and which is a dime. So we
can translate it as $\exists x(Tx \& Dx)$.

Notice that we needed to use a conditional with the universal
quantifier, but we used a conjunction with the existential quantifier.
This is a common pattern. What would it mean to write
$\exists x(Tx \supset Dx)$? Probably not what you think. It means that
there is some member of the UD which would satisfy the subformula;
roughly speaking, there is some name $\alpha$ such that
$(T\alpha \supset D\alpha)$ is true. In SL, $\Phi \supset \Psi$ is
logically equivalent to $\neg\Phi \lor \Psi$, and this will
also hold in QL. So $\exists x(Tx \supset Dx)$ is true if there is some
$\alpha$ such that $(\neg T\alpha \lor D\alpha)$; i.e., it is true if
some coin is *either* not on the table *or* is a dime. Of course there
is a coin that is not on the table --- there are coins in lots of other
places. So $\exists x(Tx \supset Dx)$ makes an extremely weak claim. A
conditional will usually be the natural connective to use with a
universal quantifier, but a conditional within the scope of an
existential quantifier can do very strange things. It's a pretty good
rule of thumb that you shouldn't be putting conditionals in the scope of
existential quantifiers. This is pretty much never a good translation of
any natural English sentence.

Sentence 14 can
be paraphrased as, 'It is not the case that every coin on the table is a
loonie.' So we can translate it as $\neg \forall x(Tx \supset Lx)$. You
might look at sentence 14 and paraphrase it instead as, 'Some coin on the table
is not a loonie.' You would then translate it as
$\exists x(Tx \& \neg Lx)$. Although it is probably not obvious,
these two translations are logically equivalent. (This is due to the
logical equivalence between $\neg\forall x\Phi$ and
$\exists x\neg\Phi$, along with the equivalence between
$\neg(\Phi\supset\Psi)$ and $\Phi\&\neg\Psi$. We'll be
able to prove this later.)

Sentence 15 can
be paraphrased as, 'It is not the case that there is some dime in my
pocket.' This can be translated as $\neg\exists x(Px \& Dx)$. It
might also be paraphrased as, 'Everything in my pocket is a non-dime,'
and then could be translated as $\forall x(Px \supset \neg Dx)$. Again the
two translations are logically equivalent. Both are correct translations
of sentence 15.

We can now translate the previous argument about Willard, the one that motivated the
need for quantifiers:


> | <span class="premise"> Willard is a logician. All logicians wear funny hats.</span>
> | <span class="conclusion"> Willard wears a funny hat.</span>

> **$UD$:** people<br/>
> **$Lx$:** $x$ is a logician.<br/>
> **$Fx$:** $x$ wears a funny hat.<br/>
> **$w$:** Willard<br/>



Translating, we get:

> | <span class="premise"> $Lw$ </span>
> | <span class="premise">$\forall x(Lx \supset Fx)$</span>
> | <span class="conclusion"> $Fw$</span>

This captures the structure that was left out of the SL translation of
this argument, and this is a valid argument in QL.

Empty predicates
----------------

A predicate need not apply to anything in the UD. A predicate that
applies to nothing in the UD is called an predicate.

Suppose we want to symbolize these two sentences:

> | 16. <span class="premise">Every monkey knows sign language.</span>
> | 17. <span class="premise">Some monkey knows sign language.</span>

It is possible to write the symbolization key for these sentences in
this way:

> **$UD$:** animals<br/>
> **$Mx$:** $x$ is a monkey.<br/>
> **$Sx$:** $x$ knows sign language.<br/>


Sentence 16 can now be translated as $\forall x(Mx \supset Sx)$.

Sentence 17 becomes $\exists x(Mx \& Sx)$.

It is tempting to say that sentence 16
entails sentence 17; that is: if every monkey knows sign language, then
it must be that some monkey knows sign language. However, the entailment
does not hold in QL. It is possible for the sentence
$\forall x(Mx \supset Sx)$ to be true even though the sentence
$\exists x(Mx \& Sx)$ is false.

How can this be? The answer comes from considering whether these
sentences would be true or false *if there were no monkeys*.

We have defined $\forall$ and $\exists$ in such a way that
$\forall\Phi$ is equivalent to $\neg \exists\neg \Phi$. As
such, the universal quantifier doesn't involve the existence of anything
--- only non-existence. If sentence 16 is
true, then there are *no* monkeys who don't know sign language. If there
were no monkeys, then $\forall x(Mx \supset Sx)$ would be true and
$\exists x(Mx \& Sx)$ would be false.

A second reason to allow empty predicates is that we want to be able to
say things like, 'I do not know if there are any monkeys, but any
monkeys that there are know sign language.' That is, we want to be able
to have predicates that do not (or might not) refer to anything.

Third, consider: $\forall x (Px \supset Px)$. This should be a tautology.
But if sentence 16 implied sentence 17, then
this would imply $\exists x (Px \& Px)$. It would become a logical
truth that for any predicate there is something that satisfies that
predicate.

What happens if we add an empty predicate $R$ to the interpretation
above? For example, we might define $Rx$ to mean '$x$ is a
refrigerator.' Now the sentence $\forall x(Rx \supset Mx)$ will be true.
This is counterintuitive, since we do not want to say that there are a
whole bunch of refrigerator monkeys. It is important to remember,
though, that $\forall x(Rx \supset Mx)$ means that any member of the UD
which is a refrigerator is a monkey. Since the UD is animals, there are
no refrigerators in the UD and so the sentence is trivially true.

If you were actually translating the sentence 'All refrigerators are
monkeys', then you would want to include appliances in the UD. Then the
predicate $R$ would not be empty and the sentence
$\forall x(Rx \supset Mx)$ would be false.


<div class="boxed-statement">
  <div>
  -   A UD must have *at least* one member.
  -   A predicate may apply to some, all, or no members of the UD.
  -   A constant must pick out *exactly* one member of the UD. A member of the UD may be picked out by one constant, many constants, or none at all.
  </div>
</div>



Picking a universe of discourse
-------------------------------

The appropriate symbolization of an English language sentence in QL will
depend on the symbolization key. In some ways, this is obvious: It
matters whether $Dx$ means '$x$ is dainty' or '$x$ is dangerous.' The
meaning of sentences in QL also depends on the UD.

Let $Rx$ mean '$x$ is a rose,' let $Tx$ mean '$x$ has a thorn,' and
consider this sentence:

> | 18. <span class="premise">Every rose has a thorn.</span>

It is tempting to say that sentence
18 should be translated as $\forall x(Rx \supset Tx)$.
If the UD contains all roses, that would be correct. Yet if the UD is
merely *things on my kitchen table*, then $\forall x(Rx \supset Tx)$ would
only mean that every rose on my kitchen table has a thorn. If there are
no roses on my kitchen table, the sentence would be trivially true.

The universal quantifier only ranges over members of the UD, so we need
to include all roses in the UD in order to translate sentence
18. We have two options. First, we can restrict the
UD to include all roses but *only* roses. Then sentence
18 becomes $\forall x Tx$. This means that
everything in the UD has a thorn; since the UD just is the set of roses,
this means that every rose has a thorn. This option can save us trouble
if every sentence that we want to translate using the symbolization key
is about roses.

Second, we can let the UD contain things besides roses: rhododendrons,
rats, rifles, and whatall else. Then sentence
18 must be $\forall x(Rx \supset Tx)$.

If we wanted the universal quantifier to mean *every* thing, without
restriction, then we might try to specify a UD that contains everything.
But this notion is somewhat obscure. Does 'everything' include things
that have only been imagined, like fictional characters? On the one
hand, we want to be able to symbolize arguments about Hamlet or Sherlock
Holmes. So we need to have the option of including fictional characters
in the UD. On the other hand, we never need to talk about every thing
that does not exist. That might not even make sense. There are
philosophical issues here that we will not try to address. We can avoid
these difficulties by always specifying the UD. For example, if we mean
to talk about plants, people, and cities, then the UD might be 'living
things and places.'

Suppose that we want to translate sentence
18 and, with the same symbolization key, translate
these sentences:

> | 19. <span class="premise">Esmerelda has a rose in her hair.</span>
> | 20. <span class="premise">Everyone is cross with Esmerelda.</span>

We need a UD that includes roses (so that we can symbolize sentence
18) and a UD that includes people (so we can
translate sentence 19--20.) Here is a suitable key:



> **$UD$:** people and plants<br/>
> **$Px$:** $x$ is a person.<br/>
> **$Rx$:** $x$ is a rose.<br/>
> **$Tx$:** $x$ has a thorn.<br/>
> **$Cxy$:** $x$ is cross with $y$.<br/>
> **$Hxy$:** $x$ has $y$ in their hair.<br/>
> **$e$:** Esmerelda<br/>

Since we do not have a predicate that means '$\ldots$ has a rose in her
hair', translating sentence
19 will require paraphrasing. The sentence says
that there is a rose in Esmerelda's hair; that is, there is something
which is both a rose and is in Esmerelda's hair. So we get:
$\exists x(Rx\ \&\ Hex)$.

It is tempting to translate sentence
20 as $\forall x Cxe$. Unfortunately, this would
mean that every member of the UD is cross with Esmerelda --- both people
and plants. It would mean, for instance, that the rose in Esmerelda's
hair is cross with her. Of course, sentence
20 does not mean that.

'Everyone' means every person, not every member of the UD. So we can
paraphrase sentence 20 as, 'Every person is cross with Esmerelda.' We
know how to translate sentences like this: $\forall x(Px \supset Cxe)$.

In general, the universal quantifier can be used to mean 'everyone' if
the UD contains only people. If there are people and other things in the
UD, then 'everyone' must be treated as 'every person'.

Translating pronouns
--------------------

When translating to QL, it is important to understand the structure of
the sentences you want to translate. What matters is the final
translation in QL, and sometimes you will be able to move from an
English language sentence directly to a sentence of QL. Other times, it
helps to paraphrase the sentence one or more times. Each successive
paraphrase should move from the original sentence closer to something
that you can translate directly into QL.

For the next several examples, we will use this symbolization key:

> **$UD$:** people<br/>
> **$Gx$:** $x$ can play guitar.<br/>
> **$Rx$:** $x$ is a rock star.<br/>
> **$c$:** Chris <br/>
> **$l$:** Lemmy<br/>


Now consider these sentences:

> | 21. <span class="premise">If Chris can play guitar, then they are a rock star.</span>
> | 22. <span class="premise">If a person can play guitar, then they are a rock star.</span>



Sentence 21 and sentence 22 have the same words in the consequent ('$\ldots$ they are a rock star'),
but they cannot be translated in the same way. It helps to paraphrase
the original sentences, replacing pronouns with explicit references.

Sentence 21 can be paraphrased as, 'If Chris can play guitar,
then *Chris* is a rockstar.' The word 'they' in sentence
21is
being used to refer to a specific individual, Chris. This can obviously
be translated as $Gc \supset Rc$.

Sentence 22 must be paraphrased differently: 'If a person can
play guitar, then *that person* is a rock star.' The pronoun 'they' here
is not about any particular person, so we need a variable. Translating
halfway, we can paraphrase the sentence as, 'For any person $x$, if $x$
can play guitar, then $x$ is a rock star.' Now this can be translated as
$\forall x (Gx \supset Rx)$. This is the same as, 'Everyone who can play
guitar is a rock star.'

Consider these further sentences:


> | 23. <span class="premise">If anyone can play guitar, then Lemmy can.</span>
> | 24. <span class="premise">If anyone can play guitar, then they are a rock star.</span>

These two sentences have the same antecedent ('If anyone can play
guitar$\ldots$'), but they have different logical structures.

Sentence 23 can be paraphrased, 'If someone can play guitar,
then Lemmy can play guitar.' The antecedent and consequent are separate
sentences, so it can be symbolized with a conditional as the main
logical operator: $\exists x Gx \supset Gl$.

Sentence 24 can be paraphrased, 'For anyone, if that one can
play guitar, then that one is a rock star.' It would be a mistake to
symbolize this with an existential quantifier, because it is talking
about everybody. The sentence is equivalent to 'All guitar players are
rock stars.' It is best translated as $\forall x(Gx \supset Rx)$.

The English words 'any' and 'anyone' should typically be translated
using quantifiers. As these two examples show, they sometimes call for
an existential quantifier (as in sentence
23) and sometimes for a universal quantifier (as in sentence
24). If you have a hard time determining which is required, paraphrase the
sentence with an English language sentence that uses words besides 'any'
or 'anyone.'

Quantifiers and scope
---------------------

In the sentence $\exists x Gx \supset Gl$, the scope of the existential
quantifier is the expression $Gx$. Would it matter if the scope of the
quantifier were the whole sentence? That is, does the sentence
$\exists x (Gx \supset Gl)$ mean something different?

With the key given above, $\exists x Gx \supset Gl$ means that if there is
some guitarist, then Lemmy is a guitarist. $\exists x (Gx \supset Gl)$
would mean that there is some person such that if that person were a
guitarist, then Lemmy would be a guitarist. Recall that the conditional
here is a material conditional; the conditional is true any time the
antecedent is false. Let the constant $p$ denote the author of this
book, someone who is certainly not a guitarist. The sentence
$Gp \supset Gl$ is true because $Gp$ is false. Since someone (namely $p$)
satisfies the sentence, then $\exists x (Gx \supset Gl)$ is true. The
sentence is true because there is a non-guitarist, regardless of Lemmy's
skill with the guitar.

Something strange happened when we changed the scope of the quantifier,
because the conditional in QL is a material conditional. In order to
keep the meaning the same, we would have to change the quantifier:
$\exists x Gx \supset Gl$ means the same thing as $\forall x (Gx \supset Gl)$,
and $\exists x (Gx \supset Gl)$ means the same thing as
$\forall x Gx \supset Gl$.

Note that quantifiers count as logical connectives, so one can sensibly
ask whether the main connective of a given sentence is a quantifier or
something else. (Calling it a 'connective' can be slightly confusing,
since, unlike connectives like conjunction and disjunction, it doesn't
literally *connect* two sentences. Quantifiers are like negations in
this respect --- each does count as a connective.) If the scope of the
quantifier is the entire sentence, then that quantifier is the main
connective, as in $\forall x (Gx \supset Gl)$. If the scope of the
quantifier is limited to a subsentence, then that quantifier is not the
main connective. For example, in $\exists x Gx \supset Gl$, the main
quantifier is the conditional; the existential is part of the
antecedent.

Ambiguous predicates
--------------------

Suppose we just want to translate this sentence:

> | 25. <span class="premise">Adina is a skilled surgeon.</span>

Let the UD be people, let $Kx$ mean '$x$ is a skilled surgeon', and let
$a$ mean Adina. Sentence 25 is simply $Ka$.

Suppose instead that we want to translate this argument:

> The hospital will only hire a skilled surgeon. All surgeons are
> greedy. Billy is a surgeon, but is not skilled. Therefore, Billy is
> greedy, but the hospital will not hire him.

We need to distinguish being a *skilled surgeon* from merely being a
*surgeon*. So we define this symbolization key:


> **$UD$:** people<br/>
> **$Gx$:** $x$ is greedy.<br/>
> **$Hx$:** The hospital will hire $x$.<br/>
> **$Rx$:** $x$ is a surgeon.<br/>
> **$Kx$:** $x$ is skilled.<br/>
> **$b$:** Billy <br/>



Now the argument can be translated in this way:


> | <span class="premise">$\forall x\bigl[\neg (Rx \& Kx) \supset \neg Hx\bigr]$</span>
> | <span class="premise"> $\forall x(Rx \supset Gx)$ </span>
> | <span class="premise"> $Rb\ \&\ \neg Kb$</span>
> | <span class="conclusion"> $Gb\ \&\ \neg Hb$</span>


Next suppose that we want to translate this argument:

> Carol is a skilled surgeon
> and a tennis player. Therefore, Carol is a skilled tennis player.

If we start with the symbolization key we used for the previous
argument, we could add a predicate (let $Tx$ mean '$x$ is a tennis
player') and a constant (let $c$ mean Carol). Then the argument becomes:

> | <span class="premise">$(Rc\ \&\ Kc)\ \&\ Tc$</span>
> | <span class="conclusion">$Tc\ \&\ Kc$</span>


This translation is a disaster! It takes what in English is a terrible
argument and translates it as a valid argument in QL. The problem is
that there is a difference between being *skilled as a surgeon* and
*skilled as a tennis player*. Translating this argument correctly
requires two separate predicates, one for each type of skill. If we let
$K_1x$ mean '$x$ is skilled as a surgeon' and $K_2x$ mean '$x$ is
skilled as a tennis player,' then we can symbolize the argument in this
way:

> | <span class="premise">$(Rc \& K_1c) \& Tc$</span>
> | <span class="conclusion">$Tc \& K_2c$</span>


Like the English language argument it translates, this is invalid.

The moral of these examples is that you need to be careful of
symbolizing predicates in an ambiguous way. Similar problems can arise
with predicates like *good*, *bad*, *big*, and *small*. Just as skilled
surgeons and skilled tennis players have different skills, big dogs, big
mice, and big problems are big in different ways.

Is it enough to have a predicate that means '$x$ is a skilled surgeon',
rather than two predicates '$x$ is skilled' and '$x$ is a surgeon'?
Sometimes. As sentence 25 shows, sometimes we do not need to distinguish
between skilled surgeons and other surgeons.

Must we always distinguish between different ways of being skilled,
good, bad, or big? No. As the argument about Billy shows, sometimes we
only need to talk about one kind of skill. If you are translating an
argument that is just about dogs, it is fine to define a predicate that
means '$x$ is big.' If the UD includes dogs and mice, however, it is
probably best to make the predicate mean '$x$ is big for a dog.'

Multiple quantifiers
--------------------

Consider this following symbolization key and the sentences that follow
it:

> **$UD$:** people and dogs<br/>
> **$Dx$:** $x$ is a dog.<br/>
> **$Fxy$:** $x$ is a friend of $y$.<br/>
> **$Oxy$:** $x$ owns $y$.<br/>
> **$f$:** Fifi<br/>
> **$g$:** Gerald <br/>

> | 26. <span class="premise">Fifi is a dog.</span>
> | 27. <span class="premise">Gerald is a dog owner.</span>
> | 28. <span class="premise">Someone is a dog owner.</span>
> | 29. <span class="premise">All of Gerald's friends are dog owners.</span>
> | 30. <span class="premise">Every dog owner is the friend of a dog owner.</span>


Sentence 26 is
easy: $Df$.

Sentence 27 can be
paraphrased as, 'There is a dog that Gerald owns.' This can be
translated as $\exists x(Dx \& Ogx)$.

Sentence 28 can be
paraphrased as, 'There is some $y$ such that $y$ is a dog owner.' The
subsentence '$y$ is a dog owner' is just like sentence
27, except that it
is about $y$ rather than being about Gerald. So we can translate
sentence 28 as
$\exists y \exists x(Dx\ \&\ Oyx)$.

Sentence 29 can be
paraphrased as, 'Every friend of Gerald is a dog owner.' Translating
part of this sentence, we get
$\forall x(Fxg \supset\text{`$x$ is a dog owner'})$. Again, it is important
to recognize that '$x$ is a dog owner' is structurally just like
sentence 27. Since
we already have an x-quantifier, we will need a different variable for
the existential quantifier. Any other variable will do. Using $z$,
sentence 29 can be
translated as $\forall x\bigl[Fxg \supset\exists z(Dz\ \&\ Oxz)\bigr]$.

Sentence 30 can be
paraphrased as 'For any $x$ that is a dog owner, there is a dog owner
who is $x$'s friend.' Partially translated, this becomes


$\forall x\bigl[\text{$x$ is a dog owner}\supset\exists y(\text{$y$ is a dog owner}\ \&\ Fxy)\bigr].$


Completing the translation, sentence
30 becomes

$\forall x\bigl[\exists z(Dz\ \&\ Oxz)\supset\exists y\bigl(\exists z(Dz\ \&\ Oyz)\ \&\ Fxy\bigr)\bigr].$



Consider this symbolization key and these sentences:



> **$UD$:** people<br/>
> **$Lxy$:** $x$ likes $y$.<br/>
> **$i$:** Imre<br/>
> **$k$:** Karl<br/>

> | 31. <span class="premise">Imre likes everyone that Karl likes.</span>
> | 32. <span class="premise">There is someone who likes everyone who likes everyone that he likes.</span>





Sentence 31
can be partially translated as
$\forall x(\text{Karl likes $x$}\supset\text{Imre likes $x$})$. This
becomes $\forall x(Lkx\supset Lix)$.

Sentence 32
is complex. There is little hope of writing down the whole translation
immediately, but we can proceed by small steps. An initial, partial
translation might look like this:

$\exists x\ \text{everyone who likes everyone that $x$ likes is liked by $x$}$

The part that remains in English is a universal sentence, so we
translate further:

$\exists x\forall y(\text{$y$ likes everyone that $x$ likes}\supset\text{$x$ likes $y$}).$

The antecedent of the conditional is structurally just like sentence
31, with $y$
and $x$ in place of Imre and Karl. So sentence
32 can be
completely translated in this way

$\exists x\forall y\bigl[\forall z(Lxz \supset Lyz) \supset Lxy\bigr]$

When symbolizing sentences with multiple quantifiers, it is best to
proceed by small steps. Paraphrase the English sentence so that the
logical structure is readily symbolized in QL. Then translate piecemeal,
replacing the daunting task of translating a long sentence with the
simpler task of translating shorter formulae.

Grammaticality rules for QL
---------------------------

In this section, we provide a formal definition for a *well-formed
formula* (wff) and *sentence* of QL.

### Expressions

There are six kinds of symbols in QL:

  ---------------------------- ----------------------------------------------
           predicates                         $A,B,C,\ldots,Z$
   with subscripts, as needed   $A_1, B_1, Z_1, A_2, A_{25}, J_{375},\ldots$
           constants                          $a,b,c,\ldots,w$
   with subscripts, as needed          $a_1, w_4, h_7, m_{32},\ldots$
           variables                              $x,y,z$
   with subscripts, as needed           $x_1, y_1, z_1, x_2,\ldots$
     sentential connectives                       , , , ,
          parentheses                              ( , )
          quantifiers                        $\forall, \exists$
  ---------------------------- ----------------------------------------------

We define an as any string of symbols of QL. Take any of the symbols of
QL and write them down, in any order, and you have an expression.

### Well-formed formulae

By definition, a is either a constant or a variable.

An is an n-place predicate followed by $n$ terms. $n$ here can be any
non-negative integer, including 0. (A 0-place predicate is an atomic
formula of QL just on its own. It does not require the addition of a
term for meaningfulness or a truth value. Note that SL atoms are 0-place
QL predicates, and so count as QL atoms too.)

Just as we did for SL, we will give a *recursive* definition for a wff
of QL. In fact, most of the definition will look like the definition of
a wff of SL: Every atomic formula is a wff, and you can build new wffs
by applying the sentential connectives.

We could just add a rule for each of the quantifiers and be done with
it. For instance: If is a wff, then $\forall x\Phi$ and
$\exists x\Phi$ are wffs. However, this would allow for some
confusing sentences like $\forall x\exists x Dx$. What could these
possibly mean? There are possible ways to give interpretations of such
sentences, but instead we will write the definition of a wff so that
such abominations do not even count as well-formed. QL will include the
rule that in order for $\forall x\Phi$ or $\exists x\Phi$ to be
a wff, must not already contain an x-quantifier. So
$\forall x \exists x Dx$ will not count as a wff because $\exists x Dx$
already contains an x-quantifier.

1.  Every atomic formula is a wff.

2.  If $\Phi$ is a wff, then $\neg\Phi$ is a wff.

3.  If $\Phi$ and $\Psi$ are wffs, then $(\Phi\&\Psi)$, is a wff.

4.  If $\Phi$  and $\Psi$ are wffs, $(\Phi\lor\Psi)$ is a wff.

5.  If $\Phi$  and $\Psi$ are wffs, then $(\Phi\supset\Psi)$ is a wff.

6.  If $\Phi$  and $\Psi$ are wffs, then $(\Phi\equiv\Psi)$ is a wff.

7.  If $\Phi$ is a wff, is a variable, and contains no $\mathcal{x}$-quantifiers, then
    $\forall\mathcal{x}\Phi$ is a wff.

8.  If $\Phi$  is a wff, is a variable, and contains no $\mathcal{x}$-quantifiers, then
    $\exists\mathcal{x}\Phi$ is a wff.

9.  All and only wffs of QL can be generated by applications of these
    rules.

Notice that the '$\mathcal{x}$' that appears in the definition above is not the
variable $x$. It is a *meta-variable* that stands in for any variable of
QL. So $\forall xAx$ is a wff, but so are $\forall yAy$, $\forall zAz$,
$\forall x_4Ax_4$, and $\forall z_9Az_9$.

We can now give a formal definition for scope: The of a quantifier is
the subformula for which the quantifier is the main logical operator.

### Sentences

A sentence is something that can be either true or false. In SL, every
wff was a sentence. This will not be the case in QL. Consider the
following symbolization key:


> **$UD$:** people<br/>
> **$Lxy$:** $x$ loves $y$.<br/>
> **$b$:** Boris<br/>


Consider the expression $Lzz$. It is an atomic formula: a two-place
predicate followed by two terms. All atomic formula are wffs, so $Lzz$
is a wff. Does it mean anything? You might think that it means that $z$
loves himself, in the same way that $Lbb$ means that Boris loves
himself. But $z$ is a variable; it does not name some person the way a
constant would. The wff $Lzz$ does not tell us how to interpret $z$.
Does it mean everyone? Anyone? Someone? Someone in particular? If we had
a $z$-quantifier, it would tell us how to interpret $z$. For instance,
$\exists zLzz$ would mean that someone loves themself.

Some formal languages treat a wff like $Lzz$ as implicitly having a
universal quantifier in front. We will not do this for QL. If you want
to say that everyone loves themself, then you need to write the
quantifier: $\forall zLzz$

In order to make sense of a variable, we need a quantifier to tell us
how to interpret that variable. The scope of an $x$-quantifier, for
instance, is the part of the formula where the quantifier tells how to
interpret $x$.

In order to be precise about this, we define a **bound variable** to be an occurrence of a
variable $\mathcal{x}$ that is within the scope of an $\mathcal{x}$-quantifier. A **free variable** is an occurrence of a variable that is not bound.

For example, consider this wff:

$\forall x(Ex \lor Dy) \supset \exists z(Rzx \supset Lzx)$

The scope of the universal quantifier $\forall x$ is $(Ex \lor Dy)$, so
the first $x$ is bound by the universal quantifier but the second and
third $x$s are free. There is no $y$-quantifier, so the $y$ is free. The
scope of the existential quantifier $\exists z$ is $(Rzx \supset Lzx)$, so
both occurrences of $z$ are bound by it. Since this wff contains
variables with no instructions for how to interpret them, we don't know
how to evaluate it. It is not a sentence.

We define a **sentence** of QL as a wff of QL that contains no free variables.

### Notational conventions

We will adopt the same notational conventions that we did for SL.
First, we may leave off the outermost parentheses of a formula. Second,
we will sometimes use square brackets '\[' and '\]' in place of
parentheses to increase the readability of formulae. Third, we give
ourselves permission to leave out parentheses between each pair of
conjuncts when writing long series of conjunctions. Fourth, we may
similarly leave out parentheses between each pair of disjuncts when
writing long series of disjunctions.

Common student errors
---------------------

A sentence that says everything with one property also has another
property should be translated as a universal governing a conditional.
Using the obvious interpretation key:

-   'Every student is working': $\forall x (Sx \supset Wx)$

-   'Every student has a friend': $\forall x (Sx \supset \exists y Fxy)$

-   'Only students with friends are working':
    $\forall x [(Sx\ \&\ Wx) \supset \exists y Fxy]$

One common error is to translate sentences of this form with a different
kind of shape --- for example, as a universal governing a conjunction,
or as an existential governing a conditional. These are very inaccurate
translations of these English sentences:

-   $\forall x (Sx\ \&\ Wx)$

-   $\forall x (Sx\ \&\ \exists y Fxy)$

-   $\forall x [(Sx\ \&\ Wx)\ \&\ \exists y Fxy]$

These say that *every* object in the UD is a student with the properties
in question. Everyone is a student that is working; everyone is a
student with a friend; everyone is a working student who has a friend.
Any time you have a universal governing a conjunction, you are making a
very strong claim --- you're not just talking about objects with a
particular property, you're saying that multiple things are true about
every single object in the domain. Be very careful if you find yourself
offering a universal over a conjunction, and make sure you don't mean to
use a conditional instead.

It is also a serious mistake to use an existential instead of a
universal for sentences like these:

-   $\exists x (Sx \supset Wx)$

-   $\exists x (Sx \supset \exists y Fxy)$

-   $\exists x [(Sx\ \&\ Wx) \supset \exists y Fxy]$

These are very weak claims. They say that there is some object in the
domain that satisfies a certain conditional. For example,
$\exists x (Sx \supset Wx)$ says there is something in the domain such
that, if it is a student, it is working. Given the truth conditions for
the material conditional, this will be true if there is even one object
in the domain that is not a student, regardless of who is and isn't
working; it will also be true if there is even one object in the domain
that is working, regardless of who is and isn't a student.

If you find yourself offering, as a translation of some English
sentence, an existential governing a conditional, you are almost
certainly making a mistake. This is not a reasonable translation of any
ordinary English sentence. You probably want either a universal over a
conditional (everything with one property has another property) or an
existential over a conjunction (there is something with the following
properties).



**Practice Exercises**
----------------------


**Part A** Using the symbolization key given, translate each English-language sentence into QL. Hint: all of these sentences are well-translated as universals
governing conditionals.

> **$UD$:** all humans and animals in the world of *Bojack Horseman*<br/>
> **$Dx$:** $x$ is a dog.<br/>
> **$Cx$:** $x$ is a cat.<br/>
> **$Hx$:** $x$ is a horse.<br/>
> **$Bx$:** $x$ is a human being.<br/>
> **$Mx$:** $x$ is a movie star.<br/>
> **$Lxy$:** $x$ lives with $y$.<br/>
> **$Rxy$:** $x$ represents $y$ (as $y$'s agent).<br/>
> **$Wxy$:** $x$ worked on a movie with $y$.<br/>
> **$b$:** Bojack<br/>
> **$c$:** Princess Caroline<br/>
> **$d$:** Dianne<br/>
> **$p$:** Mr. Peanutbutter<br/>


> | 1. <span class="premise">Every movie star is a dog.</span>
> | 2. <span class="premise">Every movie star is a dog or a cat.</span>
> | 3. <span class="premise">All dog movie stars live with a human being.</span>
> | 4. <span class="premise">Everyone who lives with Dianne is a movie star.</span>
> | 5. <span class="premise">Princess Caroline represents every dog movie star.</span>
> | 6. <span class="premise">Anyone who worked on a movie with Bojack lives with a movie star.</span>
> | 7. <span class="premise">Only humans live with Mr. Peanutbutter.</span>
> | 8. <span class="premise">Everyone who has ever worked on a movie with Bojack is either a dog, a
cat, or someone who lives with a movie star.</span>



**Part B** Using the same symbolization key, translate each English-language sentence
into QL. Hint: all of these sentences are well-translated as
existentials governing conjunctions.

To enter your solutions for automatic checking, use the following keyboard shortcuts:

<div class="table">

Symbol     Keyboard
---------- ----------
$\supset$          `->`, `=>`, `>`
$\&$          `/\`, `&`, `and`
∨          `\/`, `|`, `or`
$\equiv$          `<->`, `<=>`
¬          `-`, `~`, `not`
⊥          `!?`, `_|_`
$F_3$          `F_3`
$\exists$          `E`
$\forall$          `A`
---------- ----------

</div>


Once you have entered your solution, press "return/enter" to have it automatically checked.



~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.1 Ex(Lpx /\ Bx) : Mr. Peanutbutter lives with a human.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.2 Ex(Ldx /\ Dx /\ Wxb) : Dianne lives with a dog who worked on a movie with Bojack.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.3 Ex[Rcx /\ Hx /\ Ey(By /\Lxy)] : Princess Caroline represents a horse who lives with a human being.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.4 Ex(Bx /\ Wxp /\[Ey(Dy /\ Lxy)\/ E y(Cy /\ Lxy)]) : Some human being who worked on a movie with Mr. Peanutbutter lives with a dog or a cat.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.5 Ex(Bx /\ Mx /\ Wbx) : Bojack worked on a movie with a human movie star.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
B.6 Ex(~Bx /\ Mx /\ Wbx /\ Lxd) : Bojack worked on a movie with a nonhuman movie star who lives with Dianne.
|
~~~


**Part C** Using the same symbolization key, translate each English-language sentence
into QL. Hint: these should have different forms than the cases above.

> | 1. <span class="premise">If Mr. Peanutbutter is a movie star, then all dogs are movie stars.</span>
> | 2. <span class="premise">A dog lives with Dianne and Princess Caroline represents a horse.</span>
> | 3. <span class="premise">Princess Caroline represents a horse and a dog.</span>
> | 4. <span class="premise">Princess Caroline represents everyone.</span>
> | 5. <span class="premise">Dianne doesn't live with anyone.</span>
> | 6. <span class="premise">ANo movie star has ever worked with both Bojack and a cat on a movie.</span>
> | 7. <span class="premise">Princess Caroline is a cat, but she doesn't represent any cats.</span>



**Part D** Using the symbolization key given, translate each English-language sentence
into QL.


> **$UD$:** all animals<br/>
> **$Ax$:** $x$ is an alligator.<br/>
> **$Mx$:** $x$ is a monkey.<br/>
> **$Rx$:** $x$ is a reptile.<br/>
> **$Zx$:** $x$ lives at the zoo.<br/>
> **$Lxy$:** $x$ loves $y$.<br/>
> **$a$:** Amos<br/>
> **$b$:** Bouncer <br/>
> **$c$:** Cleo<br/>


~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.1 Za/\Zb/\Zc : Amos, Bouncer, and Cleo all live at the zoo.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.2 Rb/\~Ab : Bouncer is a reptile, but not an alligator.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.3 Lcb->Mb  : If Cleo loves Bouncer, then Bouncer is a monkey.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.4 (Ab/\Ac) -> (Lab/\Lac) : If both Bouncer and Cleo are alligators, then Amos loves them both.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.5 Ex(Rx/\Zx) : Some reptile lives at the zoo.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.6 Ax(Ax -> Rx) : Every alligator is a reptile.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.7 Ax[Zx -> (Mx \/ Ax)] : Any animal that lives at the zoo is either a monkey or an alligator.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.8 Ex(Rx/\~Ax): There are reptiles which are not alligators.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.9 Ex(Rx/\Lcx) : Cleo loves a reptile.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.10 Ax((Mx/\Zx)->Lbx) : Bouncer loves all the monkeys that live at the zoo.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.11 Ax[(Mx/\Lax)->Lxa] : All the monkeys that Amos loves love him back.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.12 ExRx -> Ra : If any animal is a reptile, then Amos is.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.13 Ax(Ax -> Rx) : If any animal is an alligator, then it is a reptile.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.14 Ax[(Mx/\Lcx)->Lax] : Every monkey that Cleo loves is also loved by Amos.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
D.15 Ex(Mx/\Lxb/\~Lbx) : There is a monkey that loves Bouncer, but Bouncer does not reciprocate this love.
|
~~~


**Part E** These are syllogistic figures identified by Aristotle and his successors, along
with their medieval names. Translate each argument into QL.

**Barbara** All $B$s are $C$s. All $A$s are $B$s.  $\therefore$ All $A$s are $C$s.

**Baroco** All $C$s are $B$s. Some $A$ is not $B$. $\therefore$ Some $A$ is not $C$.

**Bocardo** Some $B$ is not $C$. All $A$s are $B$s. $\therefore$ Some $A$ is not $C$.

**Celantes** No $B$s are $C$s. All $A$s are $B$s. $\therefore$ No $C$s are $A$s.

**Celarent**  No $B$s are $C$s. All $A$s are $B$s. $\therefore$ No $A$s are $C$s.

**Cemestres** No $C$s are $B$s. No $A$s are $B$s. $\therefore$ No $A$s are $C$s.

**Cesare** No $C$s are $B$s. All $A$s are $B$s. $\therefore$ No $A$s are $C$s.

**Dabitis** All $B$s are $C$s. Some $A$ is $B$. $\therefore$ Some $C$ is $A$.

**Darii** All $B$s are $C$s. Some $A$ is $B$. $\therefore$ Some $A$ is $C$.

**Datisi** All $B$s are $C$s. Some $A$ is $B$. $\therefore$ Some $A$ is $C$.

**Disamis** Some $B$ is $C$. All $A$s are $B$s. $\therefore$ Some $A$ is $C$.

**Ferison** No $B$s are $C$s. Some $A$ is $B$. $\therefore$ Some $A$ is not $C$.

**Ferio** No $B$s are $C$s. Some $A$ is $B$. $\therefore$ Some $A$ is not $C$.

**Festino** No $C$s are $B$s. Some $A$ is $B$. $\therefore$ Some $A$ is not $C$.

**Baralipton** All $B$s are $C$s. All $A$s are $B$s. $\therefore$ Some $C$ is $A$.

**Frisesomorum** Some $B$ is $C$. No $A$s are $B$s. $\therefore$ Some $C$ is not $A$.

**Part F** Using the symbolization key given, translate each English-language
sentence into QL.

> **$UD$:** all animals<br/>
> **$Dx$:** $x$ is an dog.<br/>
> **$Sx$:** $x$ likes samurai movies.<br/>
> **$Lxy$:** $x$ is larger than $y$.<br/>
> **$b$:** Bertie<br/>
> **$e$:** Emerson <br/>
> **$f$:** Fergis<br/>


~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.1 Db/\Sb : Bertie is a dog who likes samurai movies.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.2 Db/\De/\Df : Bertie, Emerson, and Fergis are all dogs.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.3 Leb/\Lfe : Emerson is larger than Bertie, and Fergis is larger than Emerson.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.4 Ax(Dx -> Sx) : All dogs like samurai movies.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.5 Ax(Sx -> Dx) : Only dogs like samurai movies.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.6 Ex(Dx/\Lxe) : There is a dog that is larger than Emerson.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.7 Ex(Dx/\Lxf)->Ex(Dx/\Lxe) : If there is a dog larger than Fergis, then there is a dog larger than Emerson.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.8 Ax(Lxe -> ~Sx) : No animal that likes samurai movies is larger than Emerson.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.9 ~Ex(Lxf/\Dx) : No dog is larger than Fergis.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.10 Ax(~Sx -> Lxb) : Any animal that dislikes samurai movies is larger than Bertie.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.11 Ex((Lxb/\Lex)\/(Lxe/\Lbx)) : There is an animal that is between Bertie and Emerson in size.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.12 ~Ex(Dx/\[(Lxb/\Lex)\/(Lxe/\Lbx)]) : There is no dog that is between Bertie and Emerson in size.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.13 ~Ex(Dx/\Lxx) : No dog is larger than itself.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.14 Ax(Dx -> Ey(Dy /\ Lyx)) : For every dog, there is some dog larger than it.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
F.15 ExAy(Dy -> Lyx) : There is an animal that is smaller than every dog.
|
~~~


**Part G** For each argument, write a symbolization key and translate the argument into QL.

- Nothing on my desk escapes my attention. There is a computer on my desk.
As such, there is a computer that does not escape my attention.

- All my dreams are black and white. Old TV shows are in black and white.
Therefore, some of my dreams are old TV shows.

- Neither Holmes nor Watson has been to Australia. A person could see a
kangaroo only if they had been to Australia or to a zoo. Although Watson
has not seen a kangaroo, Holmes has. Therefore, Holmes has been to a
zoo.

- No one expects the Spanish Inquisition. No one knows the troubles I've
seen. Therefore, anyone who expects the Spanish Inquisition knows the
troubles I've seen.

- An antelope is bigger than a bread box. I am thinking of something that
is no bigger than a bread box, and it is either an antelope or a
cantaloupe. As such, I am thinking of a cantaloupe.

- All babies are illogical. Nobody who is illogical can manage a
crocodile. Berthold is a baby. Therefore, Berthold is unable to manage a
crocodile.

**Part H** Using the symbolization key given, translate each English-language sentence into
QL.

> **$UD$:** candies<br/>
> **$Cx$:** $x$ has chocolate in it.<br/>
> **$Mx$:** $x$ has marzipan in it.<br/>
> **$Sx$:** $x$ has sugar in it.<br/>
> **$Tx$:** Boris has tried $x$.<br/>
> **$Bxy$:** $x$ is better than $y$.<br/>



~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.1 ~ExTx : Boris has never tried any candy.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.2 Ax(Mx -> Sx) : Marzipan is always made with sugar.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.3 Ex~Sx : Some candy is sugar-free.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.4 Ex[Cx/\~EyByx] : The very best candy is chocolate.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.5 ~ExBxx : No candy is better than itself.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.6 ~Ex(Cx/\~Sx/\Tx) : Boris has never tried sugar-free chocolate.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.7 Ex(Cx/\Tx)/\Ex(Mx/\Tx)/\~Ex(Cx/\Mx/\Tx) : Boris has tried marzipan and chocolate, but never together.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.8 Ax[Cx -> Ay(~Cy -> Bxy)] : Any candy with chocolate is better than any candy without it.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
H.9 Ax[(Cx/\Mx)->Ay[(~Cy/\~My)->Bxy]] : Any candy with chocolate and marzipan is better than any candy that lacks both.
|
~~~


**Part I** Using the symbolization key given, translate each English-language sentence into
QL.

> **$UD$:** people and dishes at a potluck<br/>
> **$Rx$:** $x$ has run out.<br/>
> **$Tx$:** $x$ is on the table.<br/>
> **$Fx$:** $x$ is food.<br/>
> **$Px$:** $x$ is a person.<br/>
> **$Lxy$:** $x$ likes $y$.<br/>
> **$e$:** Eli<br/>
> **$f$:** Francesca <br/>
> **$g$:** the guacamole <br/>


~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.1 Ax(Fx->Tx) : All the food is on the table.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.2 ~Rg->Tg : If the guacamole has not run out, then it is on the table.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.3 Ax(Px->Lxg) : Everyone likes the guacamole.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.4 Ex(Px/\Lxg) -> Leg : If anyone likes the guacamole, then Eli does.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.5 Ax((Fx/\Lfx) -> Rx) : Francesca only likes the dishes that have run out.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.6 ~Ex(Px/\Lfx)/\~Ey(Py/\Lyf)  : Francesca likes no one, and no one likes Francesca.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.7 Ax((Px/\Lxg)->Lex) : Eli likes anyone who likes the guacamole.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.8 AxAy((Px/\Py/\Lxy/\Ley) -> Lex) : Eli likes everyone who likes anyone that he likes.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
I.9 Ex(Px/\Tx) -> Ay(Fy -> Ry) : If there is a person on the table already, then all of the food must have run out.
|
~~~


**Part J** Using the symbolization key given, translate each English-language sentence into
QL.


> **$UD$:** people<br/>
> **$Dx$:** $x$ dances ballet.<br/>
> **$Fx$:** $x$ is female.<br/>
> **$Mx$:** $x$ is male.<br/>
> **$Cxy$:** $x$ is a child of $y$.<br/>
> **$Sxy$:** $x$ is a sibling of $y$.<br/>
> **$e$:** Elmer<br/>
> **$j$:** Jane <br/>
> **$p$:** Patrick <br/>


~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.1 Ax(Cxp -> Dx) : All of Patrick's children are ballet dancers.
|  Type answer here. (Press "return" to check.)
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.2 Cjp/\Fj : Jane is Patrick's daughter.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.3 Ex(Cxp/\Fx)  : Patrick has a daughter.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.4 ~ExSxj : Jane is an only child.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.5 Ax((Cxp/\Fx)->Dx)  : All of Patrick's daughters dance ballet.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.6 ~Ex(Cxp/\Mx)  : Patrick has no sons.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.7 Ex(Cjx/\Sxe/\Fj)  : Jane is Elmer's niece.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.8 Spe/\Mp : Patrick is Elmer's brother.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.9 Ax((Sxp/\Mx)->~EyCyx) : Patrick's brothers have no children.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.10 Ex(Sxj/\EyCyx/\Fj) : Jane is an aunt.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.11 Ax(Dx -> Ey(Sxy/\Fy/\Dy)) : Everyone who dances ballet has a sister who also dances ballet.
|
~~~

~~~{.Translate .FOL system="ichikawaJenkinsQL" submission="none"}
J.12 Ax((Mx/\Dx)->Ey(Cxy/\Dy)) : Every man who dances ballet is the child of someone who dances ballet.
|
~~~


**Part H** Identify which variables are bound and which are free.

> | 1. <span class="premise">$\exists x Lxy \& \forall y Lyx$</span>
> | 2. <span class="premise">$\forall x Ax \& Bx$</span>
> | 3. <span class="premise">$\forall x (Ax \& Bx) \& \forall y(Cx \& Dy)$</span>
> | 4. <span class="premise">$\forall x\exists y[Rxy \supset (Jz \& Kx)] \lor Ryx$</span>
> | 5. <span class="premise">$\forall x_1(Mx_2 \equiv Lx_2x_1) \& \exists x_2 Lx_3x_2$</span>


**Part L** Identify which of the following are substitution instances of
$\forall x Rcx$: $Rac$, $Rca$, $Raa$, $Rcb$, $Rbc$, $Rcc$, $Rcd$, $Rcx$.


Identify which of the following are substitution instances of
$\exists x\forall y Lxy$: $\forall yLby$, $\forallxLbx$, $Lab$, $\exists xLxa$.
